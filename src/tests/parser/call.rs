use crate::lexer::Token;
use crate::model::{
	Stmt, Expression, JsonExpression,
	Binary, Grouping,
	Variable, Literal,
	Callable, Call, MethodCall,
};
use super::{test_parser, should_fail};
use crate::macro_tests;

macro_tests!(
	test_parser,
	(
		function_call01,
		vec![ // "foo()"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::Call(
				Box::new(Call::new(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				))
			))
		))
	),
	(
		function_call02,
		vec![ // "foo(bar)"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("bar".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::Call(
				Box::new(Call::new(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					vec!(
						JsonExpression::Expression(
							Expression::Variable(Variable::from_str("bar").unwrap())
						)
					)
				))
			))
		))
	),
	(
		function_call03,
		vec![ // "foo(12, 34)"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("12".to_string()),
			Token::Comma,
			Token::Value("34".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::Call(
				Box::new(Call::new(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					vec!(
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("12").unwrap())
						),
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("34").unwrap())
						)
					)
				))
			))
		))
	),
	(
		function_call_multiple01,
		vec![ // "foo()()"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::Call(
				Box::new(Call::new(
					Expression::Callable(Callable::Call(
						Box::new(Call::new(
							Expression::Variable(Variable::from_str("foo").unwrap()),
							Vec::new()
						))
					)),
					Vec::new()
				))
			))
		))
	),
	(
		function_call_multiple02,
		vec![ // "foo(1)(2)"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::ParentStart,
			Token::Value("2".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::Call(
				Box::new(Call::new(
					Expression::Callable(Callable::Call(
						Box::new(Call::new(
							Expression::Variable(Variable::from_str("foo").unwrap()),
							vec!(
								JsonExpression::Expression(
									Expression::Literal(Literal::from_str("1").unwrap())
								)
							)
						))
					)),
					vec!(
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("2").unwrap())
						)
					)
				))
			))
		))
	),
	(
		function_call_multiple03,
		vec![ // foo(1 + bar(v), "hello")
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Plus,
			Token::Value("bar".to_string()),
			Token::ParentStart,
			Token::Value("v".to_string()),
			Token::ParentEnd,
			Token::Comma,
			Token::Value(r#""hello""#.to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(Expression::Binary(Binary::new(
						Expression::Literal(Literal::from_str("1").unwrap()),
						Token::Plus,
						Expression::Callable(Callable::new_call(
							Expression::Variable(Variable::from_str("bar").unwrap()),
							vec!(
								JsonExpression::Expression(
									Expression::Variable(Variable::from_str("v").unwrap())
								)
							)
						))
					).unwrap())),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str(r#""hello""#).unwrap())
					)
				)
			))
		))
	),
	(
		function_call_multiple04,
		vec![ // foo(bar(foo(bar())))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("bar".to_string()),
			Token::ParentStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("bar".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(
						Expression::Callable(Callable::new_call(
							Expression::Variable(Variable::from_str("bar").unwrap()),
							vec!(
								JsonExpression::Expression(
									Expression::Callable(Callable::new_call(
										Expression::Variable(Variable::from_str("foo").unwrap()),
										vec!(
											JsonExpression::Expression(
												Expression::Callable(Callable::new_call(
													Expression::Variable(Variable::from_str("bar").unwrap()),
													Vec::new()
												))
											)
										)
									))
								)
							)
						))
					)
				)
			))
		))
	),
	(
		function_call_multiple05,
		vec![ // foo((1 + 1))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Plus,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(
						Expression::Grouping(Grouping::new(
							Expression::Binary(Binary::new(
								Expression::Literal(Literal::from_str("1").unwrap()),
								Token::Plus,
								Expression::Literal(Literal::from_str("1").unwrap())
							).unwrap())
						))
					)
				)
			))
		))
	),
	(
		function_call_multiple06,
		vec![ // foo((1))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(
						Expression::Grouping(Grouping::new(
							Expression::Literal(Literal::from_str("1").unwrap())
						))
					)
				)
			))
		))
	)
);

macro_tests!(
	should_fail,
	(
		function_call_error_01,
		vec![ // foo(
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_02,
		vec![ // foo)
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_03,
		vec![ // foo(1
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_04,
		vec![ // foo(1,
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_05,
		vec![ // foo(1, v
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("v".to_string()),
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_06,
		vec![ // foo())
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_07,
		vec![ // foo(1))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_08,
		vec![ // foo(1,))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_09,
		vec![ // foo(1, v))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("v".to_string()),
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_10,
		vec![ // foo((1)
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	)
);
