use crate::lexer::Token;
use crate::model::{
	Stmt, Expression, JsonExpression,
	Binary, Grouping,
	Variable, Literal,
	Callable,
};
use super::{test_parser, should_fail};
use crate::macro_tests;

macro_tests!(
	test_parser,
	(
		function_call01,
		vec![ // "foo()"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				Vec::new()
			))
		))
	),
	(
		function_call02,
		vec![ // "foo(bar)"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("bar".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(
						Expression::Variable(Variable::from_str("bar").unwrap())
					)
				)
			))
		))
	),
	(
		function_call03,
		vec![ // "foo(12, 34)"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("12".to_string()),
			Token::Comma,
			Token::Value("34".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("12").unwrap())
					),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("34").unwrap())
					)
				)
			))
		))
	),
	(
		function_call_multiple01,
		vec![ // "foo()()"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Callable(Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)),
				Vec::new()
			))
		))
	),
	(
		function_call_multiple02,
		vec![ // "foo(1)(2)"
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::ParentStart,
			Token::Value("2".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Callable(Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					vec!(
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("1").unwrap())
						)
					)
				)),
				vec!(
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("2").unwrap())
					)
				)
			))
		))
	),
	(
		function_call_multiple03,
		vec![ // foo(1 + bar(v), "hello")
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Plus,
			Token::Value("bar".to_string()),
			Token::ParentStart,
			Token::Value("v".to_string()),
			Token::ParentEnd,
			Token::Comma,
			Token::Value(r#""hello""#.to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(Expression::Binary(Binary::new(
						Expression::Literal(Literal::from_str("1").unwrap()),
						Token::Plus,
						Expression::Callable(Callable::new_call(
							Expression::Variable(Variable::from_str("bar").unwrap()),
							vec!(
								JsonExpression::Expression(
									Expression::Variable(Variable::from_str("v").unwrap())
								)
							)
						))
					).unwrap())),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str(r#""hello""#).unwrap())
					)
				)
			))
		))
	),
	(
		function_call_multiple04,
		vec![ // foo(bar(foo(bar())))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("bar".to_string()),
			Token::ParentStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("bar".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(
						Expression::Callable(Callable::new_call(
							Expression::Variable(Variable::from_str("bar").unwrap()),
							vec!(
								JsonExpression::Expression(
									Expression::Callable(Callable::new_call(
										Expression::Variable(Variable::from_str("foo").unwrap()),
										vec!(
											JsonExpression::Expression(
												Expression::Callable(Callable::new_call(
													Expression::Variable(Variable::from_str("bar").unwrap()),
													Vec::new()
												))
											)
										)
									))
								)
							)
						))
					)
				)
			))
		))
	),
	(
		function_call_multiple05,
		vec![ // foo((1 + 1))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Plus,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(
						Expression::Grouping(Grouping::new(
							Expression::Binary(Binary::new(
								Expression::Literal(Literal::from_str("1").unwrap()),
								Token::Plus,
								Expression::Literal(Literal::from_str("1").unwrap())
							).unwrap())
						))
					)
				)
			))
		))
	),
	(
		function_call_multiple06,
		vec![ // foo((1))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		],
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_call(
				Expression::Variable(Variable::from_str("foo").unwrap()),
				vec!(
					JsonExpression::Expression(
						Expression::Grouping(Grouping::new(
							Expression::Literal(Literal::from_str("1").unwrap())
						))
					)
				)
			))
		))
	),
	(
		method_call_01,
		vec!( // var?foo()
			Token::DelimiterStart,
			Token::Value("var".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Variable(Variable::from_str("var").unwrap()),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_02,
		vec!( // var[2]?foo()
			Token::DelimiterStart,
			Token::Value("var[2]".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Variable(Variable::from_str("var[2]").unwrap()),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_03,
		vec!( // usr.name?foo()
			Token::DelimiterStart,
			Token::Value("usr.name".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Variable(Variable::from_str("usr.name").unwrap()),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_04,
		vec!( // 1?foo()
			Token::DelimiterStart,
			Token::Value("1".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Literal(Literal::from_str("1").unwrap()),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_05,
		vec!( // "str"?foo()
			Token::DelimiterStart,
			Token::Value(r#""str""#.to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Literal(Literal::from_str(r#""str""#).unwrap()),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_06,
		vec!( // null?foo()
			Token::DelimiterStart,
			Token::Value("null".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Literal(Literal::from_str("null").unwrap()),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_07,
		vec!( // true?foo()
			Token::DelimiterStart,
			Token::Value("true".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Literal(Literal::from_str("true").unwrap()),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_08,
		vec!( // false?foo()
			Token::DelimiterStart,
			Token::Value("false".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Literal(Literal::from_str("false").unwrap()),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_09,
		vec!( // (1)?foo()
			Token::DelimiterStart,
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Grouping(Grouping::new(
					Expression::Literal(Literal::from_str("1").unwrap())
				)),
				Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_10,
		vec!( // 1 + 1?foo()
			Token::DelimiterStart,
			Token::Value("1".to_string()),
			Token::Plus,
			Token::Value("1".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Binary(Binary::new(
				Expression::Literal(Literal::from_str("1").unwrap()),
				Token::Plus,
				Expression::Callable(Callable::new_method_call(
					Expression::Literal(Literal::from_str("1").unwrap()),
					Callable::new_call(
						Expression::Variable(Variable::from_str("foo").unwrap()),
						Vec::new()
					)
				))
			).unwrap())
		))
	),
	(
		method_call_11,
		vec!( // true && 1?foo()
			Token::DelimiterStart,
			Token::Value("true".to_string()),
			Token::And,
			Token::Value("1".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Binary(Binary::new(
				Expression::Literal(Literal::from_str("true").unwrap()),
				Token::And,
				Expression::Callable(Callable::new_method_call(
					Expression::Literal(Literal::from_str("1").unwrap()),
					Callable::new_call(
						Expression::Variable(Variable::from_str("foo").unwrap()),
						Vec::new()
					)
				))
			).unwrap())
		))
	),
	(
		method_call_12,
		vec!( // foo()?bar()?baz()
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::Question,
			Token::Value("bar".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::Question,
			Token::Value("baz".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Callable(Callable::new_method_call(
					Expression::Callable(Callable::new_call(
						Expression::Variable(Variable::from_str("foo").unwrap()),
						Vec::new()
					)),
					Callable::new_call(
						Expression::Variable(Variable::from_str("bar").unwrap()),
						Vec::new()
					)
				)),
				Callable::new_call(
					Expression::Variable(Variable::from_str("baz").unwrap()),
					Vec::new()
				)
			))
		))
	),
	(
		method_call_13,
		vec!( // foo(1, 2, 3)?add(add(1, 2), 3)
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("2".to_string()),
			Token::Comma,
			Token::Value("3".to_string()),
			Token::ParentEnd,
			Token::Question,
			Token::Value("add".to_string()),
			Token::ParentStart,
			Token::Value("add".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("2".to_string()),
			Token::ParentEnd,
			Token::Comma,
			Token::Value("3".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		),
		Stmt::Expression(JsonExpression::Expression(
			Expression::Callable(Callable::new_method_call(
				Expression::Callable(Callable::new_call(
					Expression::Variable(Variable::from_str("foo").unwrap()),
					vec!(
						JsonExpression::Expression(Expression::Literal(Literal::from_str("1").unwrap())),
						JsonExpression::Expression(Expression::Literal(Literal::from_str("2").unwrap())),
						JsonExpression::Expression(Expression::Literal(Literal::from_str("3").unwrap()))
					)
				)),
				Callable::new_call(
					Expression::Variable(Variable::from_str("add").unwrap()),
					vec!(
						JsonExpression::Expression(
							Expression::Callable(Callable::new_call(
								Expression::Variable(Variable::from_str("add").unwrap()),
								vec!(
									JsonExpression::Expression(Expression::Literal(Literal::from_str("1").unwrap())),
									JsonExpression::Expression(Expression::Literal(Literal::from_str("2").unwrap()))
								)
							))
						),
						JsonExpression::Expression(Expression::Literal(Literal::from_str("3").unwrap()))
					)
				)
			))
		))
	)
);

macro_tests!(
	should_fail,
	(
		function_call_error_01,
		vec![ // foo(
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_02,
		vec![ // foo)
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_03,
		vec![ // foo(1
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_04,
		vec![ // foo(1,
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_05,
		vec![ // foo(1, v
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("v".to_string()),
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_06,
		vec![ // foo())
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_07,
		vec![ // foo(1))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_08,
		vec![ // foo(1,))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_09,
		vec![ // foo(1, v))
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("v".to_string()),
			Token::ParentEnd,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		function_call_error_10,
		vec![ // foo((1)
			Token::DelimiterStart,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentStart,
			Token::Value("1".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		method_call_error_01,
		vec![ // ?foo()
			Token::DelimiterStart,
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		method_call_error_02,
		vec![ // v?
			Token::DelimiterStart,
			Token::Value("v".to_string()),
			Token::Question,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		method_call_error_03,
		vec![ // v??
			Token::DelimiterStart,
			Token::Value("v".to_string()),
			Token::Question,
			Token::Question,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		method_call_error_04,
		vec![ // v??foo()
			Token::DelimiterStart,
			Token::Value("v".to_string()),
			Token::Question,
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		method_call_error_05,
		vec![ // v?foo
			Token::DelimiterStart,
			Token::Value("v".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::DelimiterEnd,
			Token::Eof
		]
	),
	(
		method_call_error_06,
		vec![ // v?foo()?foo
			Token::DelimiterStart,
			Token::Value("v".to_string()),
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentStart,
			Token::Question,
			Token::Value("foo".to_string()),
			Token::ParentEnd,
			Token::DelimiterEnd,
			Token::Eof
		]
	)
);
