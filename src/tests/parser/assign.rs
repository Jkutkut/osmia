use std::collections::HashMap;
use crate::lexer::Token;
use crate::model::{
	Expression, Variable, Literal, Binary,
	Stmt, Assign, JsonExpression
};
use super::{test_parser, should_fail};
use crate::macro_tests;

macro_tests!(
	test_parser,
	(
		basic_test01, // foo = "bar"
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::Value("\"bar\"".to_string()),
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Expression(Expression::Literal(Literal::from_str("\"bar\"").unwrap()))
		))
	),
	(
		basic_test02, // foo = bar
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::Value("bar".to_string()),
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Expression(Expression::Variable(Variable::from_str("bar").unwrap()))
		))
	),
	(
		basic_test03, // foo = 2 + 2
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::Value("2".to_string()),
			Token::Plus,
			Token::Value("2".to_string()),
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Expression(Expression::Binary(Binary::new(
				Expression::Literal(Literal::from_str("2").unwrap()),
				Token::Plus,
				Expression::Literal(Literal::from_str("2").unwrap())
			).unwrap()))
		))
	),
	(
		basic_test04, // foo = bar
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::Value("bar".to_string()),
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Expression(Expression::Variable(
				Variable::from_str("bar").unwrap()
			))
		))
	),
	(
		basic_test05, // foo = bar * foo
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::Value("bar".to_string()),
			Token::Multiply,
			Token::Value("foo".to_string()),
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Expression(Expression::Binary(Binary::new(
				Expression::Variable(Variable::from_str("bar").unwrap()),
				Token::Multiply,
				Expression::Variable(Variable::from_str("foo").unwrap())
			).unwrap()))
		))
	),
	(
		array01, // foo = [1, 2]
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("2".to_string()),
			Token::ArrayEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Array(vec![
				JsonExpression::Expression(
					Expression::Literal(Literal::from_str("1").unwrap())
				),
				JsonExpression::Expression(
					Expression::Literal(Literal::from_str("2").unwrap())
				)
			])
		))
	),
	(
		array02, // foo = [1, 2,]
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("2".to_string()),
			Token::Comma,
			Token::ArrayEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Array(vec![
				JsonExpression::Expression(
					Expression::Literal(Literal::from_str("1").unwrap())
				),
				JsonExpression::Expression(
					Expression::Literal(Literal::from_str("2").unwrap())
				)
			])
		))
	),
	(
		array03, // foo = []
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::ArrayEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Array(vec![])
		))
	),
	(
		array04, // foo = [1,[2, 3]]
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::ArrayStart,
			Token::Value("2".to_string()),
			Token::Comma,
			Token::Value("3".to_string()),
			Token::ArrayEnd,
			Token::ArrayEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Array(vec![
				JsonExpression::Expression(
					Expression::Literal(Literal::from_str("1").unwrap())
				),
				JsonExpression::Array(vec![
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("2").unwrap())
						),
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("3").unwrap())
						)
					]
				)
			])
		))
	),
	(
		obj01, // foo = {}
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::ObjectEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Object(HashMap::new())
		))
	),
	(
		obj02, // foo = {"bar": 1}
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::Value(r#""bar""#.to_string()),
			Token::Colon,
			Token::Value("1".to_string()),
			Token::ObjectEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Object(HashMap::from([
				(
					"bar".to_string(),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("1").unwrap())
					)
				)
			]))
		))
	),
	(
		obj03, // foo = {"bar": 1, "baz": 2}
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::Value(r#""bar""#.to_string()),
			Token::Colon,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value(r#""baz""#.to_string()),
			Token::Colon,
			Token::Value("2".to_string()),
			Token::ObjectEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Object(HashMap::from([
				(
					"bar".to_string(),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("1").unwrap())
					)
				),
				(
					"baz".to_string(),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("2").unwrap())
					)
				)
			]))
		))
	),
	(
		obj04, // foo = {"bar": 1,}
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::Value(r#""bar""#.to_string()),
			Token::Colon,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::ObjectEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Object(HashMap::from([
				(
					"bar".to_string(),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("1").unwrap())
					)
				)
			]))
		))
	),
	(
		obj05, // foo = {"bar": 1, "baz": 2,}
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::Value(r#""bar""#.to_string()),
			Token::Colon,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value(r#""baz""#.to_string()),
			Token::Colon,
			Token::Value("2".to_string()),
			Token::Comma,
			Token::ObjectEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Object(HashMap::from([
				(
					"bar".to_string(),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("1").unwrap())
					)
				),
				(
					"baz".to_string(),
					JsonExpression::Expression(
						Expression::Literal(Literal::from_str("2").unwrap())
					)
				)
			]))
		))
	),
	(
		obj_arr01, // foo = {"bar": [1, 2]}
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::Value(r#""bar""#.to_string()),
			Token::Colon,
			Token::ArrayStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::Value("2".to_string()),
			Token::ArrayEnd,
			Token::ObjectEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Object(HashMap::from([
				(
					"bar".to_string(),
					JsonExpression::Array(vec![
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("1").unwrap())
						),
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("2").unwrap())
						)
					])
				)
			]))
		))
	),
	(
		obj_arr02, // foo = [1, {"bar": 1}]
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::Value("1".to_string()),
			Token::Comma,
			Token::ObjectStart,
			Token::Value(r#""bar""#.to_string()),
			Token::Colon,
			Token::Value("1".to_string()),
			Token::ObjectEnd,
			Token::ArrayEnd,
			Token::DelimiterEnd
		],
		Stmt::Assign(Assign::new(
			Variable::from_str("foo").unwrap(),
			JsonExpression::Array(vec![
				JsonExpression::Expression(
					Expression::Literal(Literal::from_str("1").unwrap())
				),
				JsonExpression::Object(HashMap::from([
					(
						"bar".to_string(),
						JsonExpression::Expression(
							Expression::Literal(Literal::from_str("1").unwrap())
						)
					)
				]))
			])
		))
	)
);


macro_tests!(
	should_fail,
	(
		fail01,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::DelimiterEnd
		]
	),
	(
		fail02,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq
		]
	),
	(
		fail03,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string())
		]
	),
	(
		fail04,
		vec![
			Token::DelimiterStart,
			Token::Assign
		]
	),
	(
		fail05,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::DelimiterEnd
		]
	),
	(
		fail06,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::DelimiterEnd
		]
	),
	(
		fail_array01,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::DelimiterEnd
		]
	),
	(
		fail_array02,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::Value("foo".to_string()),
			Token::DelimiterEnd
		]
	),
	(
		fail_array03,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::Value("foo".to_string()),
			Token::Comma,
			Token::DelimiterEnd,
		]
	),
	(
		fail_array04,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ArrayStart,
			Token::Comma,
			Token::ArrayEnd,
			Token::DelimiterEnd
		]
	),
	(
		fail_object01,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::DelimiterEnd
		]
	),
	(
		fail_object02,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::Value("foo".to_string()),
			Token::DelimiterEnd
		]
	),
	(
		fail_object03,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::Value("foo".to_string()),
			Token::Colon,
			Token::DelimiterEnd
		]
	),
	(
		fail_object04,
		vec![
			Token::DelimiterStart,
			Token::Assign,
			Token::Value("foo".to_string()),
			Token::AssignEq,
			Token::ObjectStart,
			Token::Value("foo".to_string()),
			Token::Colon,
			Token::Value("bar".to_string()),
			Token::DelimiterEnd
		]
	)
);
